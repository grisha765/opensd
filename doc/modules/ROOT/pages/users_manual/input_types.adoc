= Input Types

As briefly described in the xref:./profile_files.adoc#prof_section_bindings[Bindings section], the gamepad has multiple input components which can be categorized by their interface, but also by a primitive type. For example, the thumbsticks on the Steam Deck have a pair of *X* / *Y* axes (example: `LStickUp`, `LStickLeft`), which, as a primitive type are absolute, but the thumbsticks _also_ have a *touch sensor* at the top which can be read as a binary *button* primitive (`LStickTouch`) as well as a pressure level (`LStickForce`) which is read as a single *absolute axis* like a *trigger* would be.

The intent is for each input name to be as _simple and intuitive as possible_, but that's always going to be pretty subjective.  This section intends to provide a painfully detailed explanation for every individual input that can have a *binding* ; )

[#input_type_dpad]
== Directional Pad
The directional pad is just a set of four buttons which are diametrically exclusive -- you can press *up* and *left* simultaneously but you cannot press *left* and *right* simultaneously.

Naming Convention:: 
* `DPad{Up|Down|Left|Right}`

Descriptions::
* `DPadUp`: The top button on the directional pad.
* `DPadDown`: The botton button on the directional pad.
* `DPadLeft`: The left button on the directional pad.
* `DPadRight`: The right button on the directional pad.

Use::
While you can bind them to nearly anything, these buttons are usually bound to pair of https://en.wikipedia.org/wiki/Joystick#Hat_switch[*Hat*] axes, which are _typically_ axes with a range of *-1* to *1* and *0* when resting / released.  
* Button bindings to `KEY_` and `BTN_` events work directly as you might expect.
* Buttons bound to `ABS_` events emit the axis limit in the given direction.

A common configuration, as seen in the xref:./example_profile.adoc[example profile], might look like this:
[source,ini]
----
[Bindings]
DpadUp              = Gamepad   ABS_HAT0Y   -
DpadDown            = Gamepad   ABS_HAT0Y   +
DpadLeft            = Gamepad   ABS_HAT0X   -
DpadRight           = Gamepad   ABS_HAT0X   +
----

'''

[#input_type_buttons]
== Buttons
These are pretty straightforward. As you probably expect, buttons have two states.  They're *true* when pressed and *false* when released.  The Steam Deck borrows common names for most buttons, but also adds a few of it's own.  It's debatable how to organize or classify these, so I'll just sorta go by the legacy naming standards.

Naming conventions::
* `A` `B` `X` `Y` `{L|R}{1|2|3|4|5}` `Menu` `Options` `Steam` `QuickAccess`

Descriptions::
* `A`: Same as it appears on the front of the Steam Deck.
* `B`: Same as it appears on the front of the Steam Deck.
* `X`: Same as it appears on the front of the Steam Deck.
* `Y`: Same as it appears on the front of the Steam Deck.
* `L1`: The top *left* bumper / shoulder button.
* `R1`: The top *right* bumper / shoulder button.
* `L2`: Button nested inside the pressure sensor of the *left* trigger.
* `R2`: Button nested inside the pressure sensor of the *right* trigger.
* `L3`: Button nested at the bottom of the *left* stick.  Activated by pressing down until it clicks.
* `R3`: Button nested at the bottom of the *right* stick.  Activated by pressing down until it clicks.
* `L4`: Upper paddle button located on the *back-left* side of the Steam Deck.
* `R4`: Upper paddle button located on the *back-right* side of the Steam Deck.
* `L5`: Lower paddle button located on the *back-left* side of the Steam Deck.
* `R5`: Lower paddle button located on the *back-right* side of the Steam Deck.
* `Menu`: Raised https://en.wikipedia.org/wiki/Hamburger_button[hamburger button] (☰) located above the *right *thumbstick.
* `Options`: Raised overlapped rectangle button (⮻) located above the *left* thumbstick.
* `Steam`: Flat button of the same name (STEAM), located below the *left* trackpad.
* `QuickAccess`: Flat button with three interpuncts (···), located below the *right* trackpad.

Use::
Binding buttons is simple.
* Button bindings to `KEY_` and `BTN_` events work directly.
* Buttons bound to `ABS_` events emit the axis limit in the given direction.  For example, if you create a binding like `A = ABS_X +`, then when you press the `A` button, it will emit an `ABS_X` event for whatever the *maximum* axis limit for `ABS_X` is, whereas `A = ABS_X -` will emit the *minimum* axis limit.
* `A`/`B`/`X`/`Y` have respective input codes for `Gamepad` devices: `BTN_SOUTH`, `BTN_EAST`, `BTN_WEST` and `BTN_NORTH`.
* `{L|R}{1|2}` have respective input codes for `Gamepad` devices: `BTN_TL` `BTN_TL2` `BTN_TR` and `BTN_TR2`.
* `{L|R}3` have respective input codes for `Gamepad` devices: `BTN_THUMBL` and `BTN_THUMBR`
* `Menu` has a respective (based on location and common use) input code for `Gamepad` devices: `BTN_START`.
* `Options` has a respective (based on location and common use) input code for `Gamepad` devices: `BTN_SELECT`.
* `Steam` is probably closest to a PS or HOME button on a `Gamepad` device; possibly use `BTN_MODE`.

'''

[#input_type_thumb]
== Thumbsticks
The thumbsticks on the Steam Deck are associated with six different inputs in OpenSD.  As you would expect, there is an *X*/*Y* axis pair for each stick, but there are also *touch* and *pressure* (well, sorta) sensors located on the top of each one.  The directional axes are broken into halves such that each direction can emit different events if desired.

Axis values from thumbsticks are normalized internally so they can be rescaled to the defined *ABS* event ranges.  The hardware returns signed 16-bit integer values for axis values in the HID reports.  The "pressure sensor" component has a very short numerical range, but is quite sensitive.

If xref:./profile_files.adoc#prof_section_features_stickfiltering[Stick Filtering] is enabled the full axis is internally normalized as a unit vector and a *radial deadzone* may be applied.

Naming convention::
* `{L|R}Stick{Up|Down|Left|Right|Touch|Force}`

Descriptions::
* `LStickUp`: Represents the top half of the *Y-axis* of the *left* thumbstick.
* `LStickDown`: Represents the bottom half of the *Y-axis* of the *left* thumbstick.
* `LStickLeft`: Represents the left half of the *X-axis* of the *left* thumbstick.
* `LStickRight`: Represents the right half of the *X-axis* of the *left* thumbstick.
* `LStickTouch`: This is a binary *button* that return *true* when the top of the *left* thumbstick is touched.
* `LStickForce`: Capacitive touch sensor at the top of the *left* thumbstick.  It is _very_ sensitive and can register if your hand is _near_, without actually touching it.  At a hardware level, the sensitivity ranges from *0* to *~112*, which is an odd number.  This value is returned as an normalized axis (*0* to *1.0*), just like a trigger.  
* `RStickUp`: Represents the top half of the *Y axis* of the *right* thumbstick.
* `RStickDown`: Represents the bottom half of the *Y axis* of the *right* thumbstick.
* `RStickLeft`: Represents the left half of the *X axis* of the *right* thumbstick.
* `RStickRight`: Represents the right half of the *X axis* of the *right* thumbstick.
* `RStickTouch`: This is a binary *button* that return *true* when the top of the *right* thumbstick is touched.
* `RStickForce`: Capacitive touch sensor at the top of the *right* thumbstick.  It is _very_ sensitive and can register if your hand is _near_, without actually touching it.  At a hardware level, the sensitivity ranges from *0* to *~112*, which is an odd number.  This value is returned as an normalized axis (*0* to *1.0*), just like a trigger.  

Use::
Directional inputs are treated like axis halves.  You typically want to map `Up` and `Down` onto the same *ABS* event code, but in opposite directions. Doing so will perfectly map the full range of motion to an event code.  An example of this, as demonstrated in the *[Bindings]* section of the xref:./example_profile.adoc[example profile]:
[source,ini]
----
# Left Stick
LStickUp            = Gamepad   ABS_Y       -
LStickDown          = Gamepad   ABS_Y       +
LStickLeft          = Gamepad   ABS_X       -
LStickRight         = Gamepad   ABS_X       +
# Right Stick
RStickUp            = Gamepad   ABS_RY      -
RStickDown          = Gamepad   ABS_RY      +
RStickLeft          = Gamepad   ABS_RX      -
RStickRight         = Gamepad   ABS_RX      +
----
You're also able to treat each axis half like a *button* if you bind it to a *key* or *button* event code, in which case it will trigger the binding when the stick leaves the *center* / *deadzone*.  You can use the deadzone in this case to determine how far the stick must be pushed from center before the binding is triggered.

* `LStickLeft` & `LStickRight` are typically bound to the `ABS_X` event code on `Gamepad` devices.
* `LStickUp` & `LStickDown` are typically bound to the `ABS_Y` event code on `Gamepad` devices.
* `RStickLeft` & `RStickRight` are typically bound to the `ABS_RX` event code on `Gamepad` devices.
* `RStickUp` & `RStickDown` are typically bound to the `ABS_RY` event code on `Gamepad` devices.
* Use `LStickTouch` / `RStickTouch` to detect if a players hands are on the controls.
* Use `LStickForce` / `RStickForce` if you want to write a tiny electric theremin simulator?  If this sensor is bound to an absolute axis, a range of *0* to *100* is recommened.

'''

[#input_type_trigg]
== Triggers
Triggers are pressure sensors that are also treated a bit like a thumbstick's half-axis, with the difference being there's no complement half.  Triggers have a resting position of the defined axis *minimum* limit and move toward the *maximum* limit when actuated.  _Typically_ the minimum limit is zero, so the axis does not return non-zero values when released / resting, but you can do any weird thing you want.

Axis values from triggers are normalized internally so they can be rescaled to the defined *ABS* event ranges.  Internally, the HID reports return trigger values as unsigned 16-bit integers.

Triggers also have a binary *button* component: `L2` and `R2`.  Information about these buttons can be found in the <<input_type_buttons>> section.

Linear deadzones can be applied to triggers, if desired in the xref:./profile_files.adoc#prof_section_deadzones[Deadzones Section] of a profile.

Naming convention::
* `{L|R}Trigg`

Descriptions::
* `LTrigg`: Represents a pressure sensor value for the *left* trigger on the top-rear of the device.
* `RTrigg`: Represents a pressure sensor value for the *right* trigger on the top-rear of the device.

Use::
These inputs are absolute axes and can be mapped to *ABS* event codes as well as *KEY* / *BTN* event codes.  One possible reason to use the axis itself as a *button*-type binding would be to use `L2` / `R2` buttons on partial actuation, and use a deadzone to emit another event code on full actuation.
* `LTrigg` is typically bound to `ABS_Z`.
* `RTrigg` is typically bound to `ABS_RZ`.

'''

[#input_type_trackpad]
== Trackpads
At the core, trackpads are *absolute axis* devices have with an *X* / *Y* pair, as well as a pressure sensor *Z-axis* and a slightly tactile *button*.  A number of inputs can be extrapolated from the data those basic types provide.  That includes *touch* sensors, *press / button* sensors, *pressure / force* sensors, *absolute coordinates*, *relative movement* tracking as well as the ability to *map* out regions of the pad and treat them as individual *buttons*.  OpenSD trackpads have the most input bindings out of all the components.

As with the <<input_type_thumb>>, directional axes are broken into halves such that each direction can emit different events if desired.  These halves can be mapped on to a whole *ABS* event code, or use separately.

Trackpads support radial deadzones for *absolute axis* inputs, and can be configured in the xref:./profile_files.adoc#prof_section_deadzones[Deadzones Section] of a profile.

*Relative* trackpad input, such as `LPadRelX` or `LPadRelY`, are not affected by deadzones and return data suitable for pointing devices like mice.  These return the *difference* in positional movement calculated between HID frames.  Some filtering is always applied to this process to reduce jitter and a small amount of intertia is also applied.  The typical value range returned by these inputs is usually between *-5* and *+5*.  Binding `*RelX` and `*RelY` inputs to anything other than `REL_*` event codes on the `Mouse` device is probably not useful.

Touchpads are non-multitouch devices so they only relay a single *X* / *Y* coordinate pair.  I've read that, at a hardware level, they are supposedly multi-touch capable, but I don't have any information on reading that data yet.  If true, it will probably be supported in a future version.

OpenSD provides multiple *"button maps"*, any of which can be used non-exclusively with each other.  These "button maps" break the full area of the trackpad into logical sections which, when *pressed* (as opposed to being merely touched) act as individual buttons.  If so desired, trackpads can be used to create "button clusters", which can be used to emulate a <<input_type_dpad>>, *arrow keys*, run scripts, launch applications, etc.  For the sake of readability, button maps are described separately below the main input descriptions.

Naming convention::
* `{L|R}Pad{Up|Down|Left|Right|Touch|Press|Force|RelX|RelY}`
* `{L|R}PadPressQuad{Up|Down|Left|Right}`
* `{L|R}PadPressOrth{Up|Down|Left|Right}`
* `{L|R}PadPressGrid2x2_{1|2|3|4}`
* `{L|R}PadPressGrid3x3_{1|2|3|4|5|6|7|8|9}`

Descriptions::
* `LPadUp`: Represents the top half of the *Y-axis* of the *left* trackpad.
* `LPadDown`: Represents the bottom half of the *Y-axis* of the *left* trackpad.
* `LPadLeft`: Represents the left half of the *X-axis* of the *left* trackpad.
* `LPadRight`: Represents the right half of the *X-axis* of the *left* trackpad.
* `LPadTouch`: This is a button sensor which detects if the *left* pad is being touched.  Quite sensitive.
* `LPadPress`: This is also a button which detects if the *left* pad is being pressed down like a button.  Actuation has a slight tactile bump.
* `LPadForce`: This is a pressure sensor which returns a normalized value of how much force is being used to press down on the *left* trackpad.  This is an *absolute axis* value and behaves the same as <<input_type_trigg>>.
* `LPadRelX`: This is a derived *relative axis* value that measures the amount of relative *X-axis* movement between update frames of the *left* trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of *-5* to *+5*.
* `LPadRelY`: This is a derived *relative axis* value that measures the amount of relative *Y-axis* movement between update frames of the *left* trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of *-5* to *+5*.
* `RPadUp`: Represents the top half of the *Y-axis* of the *right* trackpad.
* `RPadDown`: Represents the bottom half of the *Y-axis* of the *right* trackpad.
* `RPadLeft`: Represents the left half of the *X-axis* of the *right* trackpad.
* `RPadRight`: Represents the right half of the *X-axis* of the *right* trackpad.
* `RPadTouch`: This is a button sensor which detects if the *right* pad is being touched.  Quite sensitive.
* `RPadPress`: This is also a button which detects if the *right* pad is being pressed down like a button.  Actuation has a slight tactile bump.
* `RPadForce`: This is a pressure sensor which returns a normalized value of how much force is being used to press down on the *right* trackpad.  This is an *absolute axis* value and behaves the same as <<input_type_trigg>>.
* `RPadRelX`: This is a derived *relative axis* value that measures the amount of relative *X-axis* movement between update frames of the *right* trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of *-5* to *+5*.
* `RPadRelY`: This is a derived *relative axis* value that measures the amount of relative *Y-axis* movement between update frames of the *right* trackpad.  This represents the same kind of input data that mice use.  This input is unaffected by deadzones.  Typical values returned fall inside the range of *-5* to *+5*.

[#input_type_trackpad_quad]
=== Quadrant Button Map
The *quadrant map* (`PadPressQuad*`) provides a way to treat each touchpad as being composed of four *non-overlapping* triagular quadrants, as depicted in the *figure 1* below.  Each *button* is inherently exclusive to the others in this map since the *X* / *Y* coordinate can only fall inside of one of these regions at a time.  This means that this map will not detect any overlapping presses, like *a* and *b* when you press in the upper-left region.

Fig. 1
....
┌─────────────┐
│ \         / │
│  \   a   /  │
│   \     /   │
│    \   /    │
│     \ /     │
│ b    X    c │
│     / \     │
│    /   \    │
│   /     \   │
│  /   d   \  │
│ /         \ │
└─────────────┘
....

* `LPadPressQuadUp`: The logical *button* on the *left* trackpad corresponding to *fig. 1*, region *"a"*.
* `LPadPressQuadDown`: The logical *button* on the *left* trackpad corresponding to *fig. 1*, region *"d"*.
* `LPadPressQuadLeft`: The logical *button* on the *left* trackpad corresponding to *fig. 1*, region *"b"*.
* `LPadPressQuadRight`: The logical *button* on the *left* trackpad corresponding to *fig. 1*, region *"c"*.
* `RPadPressQuadUp`: The logical *button* on the *right* trackpad corresponding to *fig. 1*, region *"a"*.
* `RPadPressQuadDown`: The logical *button* on the *right* trackpad corresponding to *fig. 1*, region *"d"*.
* `RPadPressQuadLeft`: The logical *button* on the *right* trackpad corresponding to *fig. 1*, region *"b"*.
* `RPadPressQuadRight`: The logical *button* on the *right* trackpad corresponding to *fig. 1*, region *"c"*.

'''

[#input_type_trackpad_orth]
=== Orthogonal Button Map
The *orthogonal map* (`PadPressOrth*`) works similarly to a <<input_type_dpad>>.  As you can see below in figure 2, it demonstrates how the *"a"*, *"b"*, *"c"* and *"d"* regions represent orthogonal directions which are not strictly exclusive as they are with the <<input_type_trackpad_quad>>.  If a diagonal corner is pressed, it triggers both orthogonally adjacent buttons.  For example, pressing the upper-middle of the pad only triggers *"a"*, but pressing the upper-left of the pad will trigger both *"a"* and *"b"*.

Fig. 2
....
┌─────┬─────┬─────┐
│     │     │     │
│  ab │  a  │  ac │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  b  │     │  c  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  db │  d  │  dc │
│     │     │     │
└─────┴─────┴─────┘
....

* `LPadPressOrthUp`: The logical *button* on the *left* trackpad corresponding to *fig. 2* regions containing *"a"*.
* `LPadPressOrthDown`: The logical *button* on the *left* trackpad corresponding to *fig. 2* regions containing *d"*.
* `LPadPressOrthLeft`: The logical *button* on the *left* trackpad corresponding to *fig. 2* regions containing *"b"*.
* `LPadPressOrthRight`: The logical *button* on the *left* trackpad corresponding to *fig. 2* regions containing *"c"*.
* `RPadPressOrthUp`: The logical *button* on the *right* trackpad corresponding to *fig. 2* regions containing *"a"*.
* `RPadPressOrthDown`: The logical *button* on the *right* trackpad corresponding to *fig. 2* regions containing *d"*.
* `RPadPressOrthLeft`: The logical *button* on the *right* trackpad corresponding to *fig. 2* regions containing *"b"*.
* `RPadPressOrthRight`: The logical *button* on the *right* trackpad corresponding to *fig. 2* regions containing *"c"*.

'''

[#input_type_trackpad_grid4]
=== 2x2 Grid Button Map
This button map divides the pad into regions along the center axes, resulting in four square *buttons* in each corner, as depicted in figure 3.  Buttons are naturally exclusive, so only one can be pressed at a time.  Buttons are enumerated left-to-right, top-to-bottom.

Fig. 3
....
┌────────┬────────┐
│        │        │
│        │        │
│   a    │    c   │
│        │        │
│        │        │
├────────┼────────┤
│        │        │
│        │        │
│   c    │    d   │
│        │        │
│        │        │
└────────┴────────┘
....

* `LPadPressGrid2x2_1`: The logical *button* on the *left* trackpad corresponding to *fig. 3*, region *"a"*.
* `LPadPressGrid2x2_2`: The logical *button* on the *left* trackpad corresponding to *fig. 3*, region *"b"*.
* `LPadPressGrid2x2_3`: The logical *button* on the *left* trackpad corresponding to *fig. 3*, region *"c"*.
* `LPadPressGrid2x2_4`: The logical *button* on the *left* trackpad corresponding to *fig. 3*, region *"d"*.
* `RPadPressGrid2x2_1`: The logical *button* on the *right* trackpad corresponding to *fig. 3*, region *"a"*.
* `RPadPressGrid2x2_2`: The logical *button* on the *right* trackpad corresponding to *fig. 3*, region *"b"*.
* `RPadPressGrid2x2_3`: The logical *button* on the *right* trackpad corresponding to *fig. 3*, region *"c"*.
* `RPadPressGrid2x2_4`: The logical *button* on the *right* trackpad corresponding to *fig. 3*, region *"d"*.

'''

[#input_type_trackpad_grid9]
=== 3x3 Grid Button Map
This button map divides the pad into thirds along both axes, resulting in a 3x3 grid of nine square *buttons*, as depicted in figure 4.  These buttons are naturally exclusive to one another, so only one can be pressed at a time.  Buttons are enumerated left-to-right, top-to-bottom.

NOTE:  The resulting size of each button will be fairly small, so it may require a little practice and small thumbs to manipulate them precisely.

Fig. 4
....
┌─────┬─────┬─────┐
│     │     │     │
│  a  │  b  │  c  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  d  │  e  │  f  │
│     │     │     │
├─────┼─────┼─────┤
│     │     │     │
│  g  │  h  │  i  │
│     │     │     │
└─────┴─────┴─────┘
....

* `LPadPressGrid3x3_1`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"a"*.
* `LPadPressGrid3x3_2`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"b"*.
* `LPadPressGrid3x3_3`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"c"*.
* `LPadPressGrid3x3_4`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"d"*.
* `LPadPressGrid3x3_5`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"e"*.
* `LPadPressGrid3x3_6`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"f"*.
* `LPadPressGrid3x3_7`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"g"*.
* `LPadPressGrid3x3_8`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"h"*.
* `LPadPressGrid3x3_9`: The logical *button* on the *left* trackpad corresponding to *fig. 4*, region *"i"*.
* `RPadPressGrid3x3_1`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"a"*.
* `RPadPressGrid3x3_2`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"b"*.
* `RPadPressGrid3x3_3`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"c"*.
* `RPadPressGrid3x3_4`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"d"*.
* `RPadPressGrid3x3_5`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"e"*.
* `RPadPressGrid3x3_6`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"f"*.
* `RPadPressGrid3x3_7`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"g"*.
* `RPadPressGrid3x3_8`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"h"*.
* `RPadPressGrid3x3_9`: The logical *button* on the *right* trackpad corresponding to *fig. 4*, region *"i"*.

'''
